version = 1
[common]
# API mode, set to true to prevent loading local subscriptions or serving local files directly
api_mode = false

# Access token used for performing critical action through Web interface
api_access_token = "si"

# Default URLs, used when no URL is provided in request, use "|" to separate multiple subscription links, supports local files/URL
default_url = []

# Insert subscription links to requests. Can be used to add node(s) to all exported subscriptions.
enable_insert = true
# URLs to insert before subscription links, can be used to add node(s) to all exported subscriptions, supports local files/URL
insert_url = [""]
# Prepend inserted URLs to subscription links. Nodes in insert_url will be added to groups first with non-group-specific match pattern.
prepend_insert_url = true

# Exclude nodes which remarks match the following patterns. Supports regular expression.
exclude_remarks = ["(åˆ°æœŸ|å‰©ä½™æµé‡|æ—¶é—´|å®˜ç½‘|äº§å“|åŸŸå|è®¿é—®|å¤±è”|é‚®ç®±)"]

# Only include nodes which remarks match the following patterns. Supports regular expression.
#include_remarks = ["V3.*æ¸¯"]

# Enable script support for filtering nodes
enable_filter = false
# Script used for filtering nodes. Supports inline script and script path. A "filter" function with 1 argument which is a node should be defined in the script.
# Example: Inline script: Set value to content of script.
#          Script path: Set value to "path:/path/to/script.js".
#filter_script = '''
#function filter(node) {
#    const info = JSON.parse(node.ProxyInfo);
#    if(info.EncryptMethod.includes('chacha20'))
#	    return true;
#    return false;
#}
#'''

# Setting an external config file as default when none is specified, supports local files/URL
# default_external_config = "config/example_external_config.toml"

# The file scope limit of the 'rule_base' options in external configs.
base_path = "base"

# Clash config base used by the generator, supports local files/URL
clash_rule_base = "base/all_base.tpl"

# Surge config base used by the generator, supports local files/URL
surge_rule_base = "base/all_base.tpl"

# Surfboard config base used by the generator, supports local files/URL
surfboard_rule_base = "base/all_base.tpl"

# Mellow config base used by the generator, supports local files/URL
mellow_rule_base = "base/all_base.tpl"

# Quantumult config base used by the generator, supports local files/URL
quan_rule_base = "base/all_base.tpl"

# Quantumult X config base used by the generator, supports local files/URL
quanx_rule_base = "base/all_base.tpl"

# Loon config base used by the generator, supports local files/URL
loon_rule_base = "base/all_base.tpl"

# Shadowsocks Android config base used by the generator, supports local files/URL
sssub_rule_base = "base/all_base.tpl"

# sing-box config base used by the generator, supports local files/URL
singbox_rule_base = "base/all_base.tpl"

# Proxy used to download rulesets or subscriptions, set to NONE or empty to disable it, set to SYSTEM to use system proxy.
# Accept cURL-supported proxies (http:// https:// socks4a:// socks5://)

proxy_config = "SYSTEM"
proxy_ruleset = "SYSTEM"
proxy_subscription = "NONE"

# Append a proxy type string ([SS] [SSR] [VMess]) to node remark.
append_proxy_type = false

# When requesting /sub, reload this config file first.
reload_conf_on_request = false

[[userinfo.stream_rule]]
# Rules to extract stream data from node
# Format: full_match_regex|new_format_regex
# where new_format_regex should be like "total=$1&left=$2&used=$3"
match = '^å‰©ä½™æµé‡ï¼š(.*?)\|æ€»æµé‡ï¼š(.*)$'
replace = 'total=$2&left=$1'

[[userinfo.stream_rule]]
match = '^å‰©ä½™æµé‡ï¼š(.*?) (.*)$'
replace = 'total=$1&left=$2'

[[userinfo.stream_rule]]
match = '^Bandwidth: (.*?)/(.*)$'
replace = 'used=$1&total=$2'

[[userinfo.stream_rule]]
match = '^.*å‰©ä½™(.*?)(?:\s*?)@(?:.*)$'
replace = 'total=$1'

[[userinfo.time_rule]]
# Rules to extract expire time data from node
# Format: full_match_regex|new_format_regex
# where new_format_regex should follow this example: yyyy:mm:dd:hh:mm:ss
match = '^è¿‡æœŸæ—¶é—´ï¼š(\d+)-(\d+)-(\d+) (\d+):(\d+):(\d+)$'
replace = '$1:$2:$3:$4:$5:$6'

[[userinfo.time_rule]]
match = '^åˆ°æœŸæ—¶é—´:(\d+)-(\d+)-(\d+)$'
replace = '$1:$2:$3:0:0:0'

[[userinfo.time_rule]]
match = '^Smart Access expire: (\d+)/(\d+)/(\d+)$'
replace = '$1:$2:$3:0:0:0'

[node_pref]
#udp_flag = false
#tcp_fast_open_flag = false
#skip_cert_verify_flag = false
#tls13_flag = false

sort_flag = false
# Script used for sorting nodes. A "compare" function with 2 arguments which are the 2 nodes to be compared should be defined in the script. Supports inline script and script path.
# Examples can be seen at the filter_script option in [common] section.
sort_script = '''
function extractNodeName(remark) {
    // é€šè¿‡ç©ºæ ¼åˆ†å‰²ï¼Œå–æœ€åä¸€ä½æ¥å»é™¤emojiå’Œå…¶ä»–å‰ç¼€
    const parts = remark.trim().split(/\s+/);
    return parts[parts.length - 1];
}

function isChinese(text) {
    // ç®€å•æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦åŒ…å«æ±‰å­—ï¼Œè¿™é‡Œå‡è®¾æ±‰å­—ç¼–ç èŒƒå›´ä¸»è¦åœ¨\u4e00åˆ°\u9fffä¹‹é—´
    return /[\u4e00-\u9fff]/.test(text);
}

function containsDownload(text) {
    // æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦åŒ…å«"ä¸‹è½½"ä¸¤ä¸ªå­—
    return text.includes("ä¸‹è½½");
}

function containsBei(text) {
    // æ£€æŸ¥å­—ç¬¦ä¸²æ˜¯å¦åŒ…å«"å¤‡ç”¨"ä¸¤ä¸ªå­—
    return text.includes("å¤‡ç”¨");
}

// ã€æ–°å¢ã€‘æå–å¤‡ç”¨ç­‰çº§æ•°å­—ï¼Œå¦‚æœæ²¡æœ‰æ•°å­—åˆ™è¿”å› 0
function getBeiLevel(text) {
    const match = text.match(/ã€å¤‡ç”¨(\d+)ã€‘/);
    if (match) {
        return parseInt(match[1], 10);
    }
    // å¦‚æœåŒ…å«â€œå¤‡ç”¨â€å­—æ ·ä½†æ²¡æ•°å­—ï¼ˆé˜²æ­¢æ¼ç½‘ï¼‰ï¼Œè§†ä¸ºæœ€å¤§ç­‰çº§æˆ–æŒ‰éœ€å¤„ç†ï¼Œè¿™é‡Œæš‚å®šä¸º0
    return 0;
}

function naturalSort(a, b) {
    // è‡ªç„¶æ’åºï¼Œæ”¯æŒæ•°å­—å’Œå­—æ¯æ··åˆæ’åº
    const regex = /(\d+|\D+)/g;
    const aParts = a.match(regex) || [];
    const bParts = b.match(regex) || [];

    const maxLength = Math.max(aParts.length, bParts.length);

    for (let i = 0; i < maxLength; i++) {
        const aPart = aParts[i] || '';
        const bPart = bParts[i] || '';

        // å¦‚æœéƒ½æ˜¯æ•°å­—ï¼ŒæŒ‰æ•°å­—å¤§å°æ¯”è¾ƒ
        if (/^\d+$/.test(aPart) && /^\d+$/.test(bPart)) {
            const diff = parseInt(aPart, 10) - parseInt(bPart, 10);
            if (diff !== 0) {
                return diff;
            }
        } else {
            // å¦åˆ™æŒ‰å­—ç¬¦ä¸²æ¯”è¾ƒ
            const diff = aPart.toLowerCase().localeCompare(bPart.toLowerCase());
            if (diff !== 0) {
                return diff;
            }
        }
    }

    return 0;
}

function compare(node_a, node_b) {
    // æå–å¤„ç†åçš„èŠ‚ç‚¹åç§°
    const remarkA_Full = node_a.Remark;
    const remarkB_Full = node_b.Remark;
    //const remarkA = extractNodeName(node_a.Remark);
    //const remarkB = extractNodeName(node_b.Remark);

    // 1. å¤‡ç”¨èŠ‚ç‚¹ä¼˜å…ˆçº§æœ€ä½ï¼ˆæ’åœ¨æœ€åï¼‰
    // è¿™é‡Œç»“åˆäº†æ­£åˆ™æå–çš„ç­‰çº§å’Œç®€å•çš„æ–‡å­—åŒ…å«åˆ¤æ–­
    const levelA = getBeiLevel(remarkA_Full);
    const levelB = getBeiLevel(remarkB_Full);
    const isBeiA = levelA > 0 || containsBei(remarkA_Full);
    const isBeiB = levelB > 0 || containsBei(remarkB_Full);

    if (isBeiA !== isBeiB) {
        return isBeiA ? false : true; // Aæ˜¯å¤‡ç”¨åˆ™æ’åé¢(false)ï¼Œå¦åˆ™æ’å‰é¢(true)
    }

    // 2. ã€æ–°å¢å…³é”®é€»è¾‘ã€‘å¦‚æœéƒ½æ˜¯å¤‡ç”¨èŠ‚ç‚¹ï¼ŒæŒ‰æ•°å­—ç­‰çº§ä»å°åˆ°å¤§æ’åº (1 -> 2 -> 3)
    // è¿™ä¸€æ­¥å¿…é¡»åœ¨â€œä¸­è‹±æ–‡æ’åºâ€ä¹‹å‰æ‰§è¡Œ
    if (isBeiA && isBeiB) {
        if (levelA !== levelB) {
            return levelA < levelB; // ç­‰çº§å°çš„åœ¨å‰ (1 åœ¨ 3 å‰)
        }
    }

    // 2. åŒ…å«"ä¸‹è½½"çš„èŠ‚ç‚¹æ¬¡å
    const aContainsDownload = containsDownload(remarkA_Full);
    const bContainsDownload = containsDownload(remarkB_Full);

    if (aContainsDownload !== bContainsDownload) {
        return aContainsDownload ? false : true; // åŒ…å«ä¸‹è½½çš„æ’åœ¨åé¢ï¼Œè¿”å›falseè¡¨ç¤ºaåœ¨å
    }

    // 3. è‹±æ–‡åœ¨å‰ï¼Œæ±‰å­—åœ¨å
    const aIsChinese = isChinese(remarkA_Full);
    const bIsChinese = isChinese(remarkB_Full);

    if (aIsChinese !== bIsChinese) {
        return aIsChinese ? false : true; // æ±‰å­—æ’åœ¨åé¢ï¼Œè¿”å›falseè¡¨ç¤ºaåœ¨å
    }

    // 4. æœ€åæŒ‰ç…§æ•°å­—æˆ–å­—æ¯ä»å°åˆ°å¤§æ’åºï¼ˆè‡ªç„¶æ’åºï¼‰
    const sortResult = naturalSort(remarkA_Full, remarkB_Full);
    if (sortResult < 0) {
        return true; // aåº”è¯¥åœ¨å‰é¢
    } else if (sortResult > 0) {
        return false; // aåº”è¯¥åœ¨åé¢
    } else {
        return true; // ç›¸ç­‰æ—¶ä¿æŒåŸé¡ºåºï¼Œè¿”å›trueè¡¨ç¤ºaåœ¨å‰
    }
}
'''

filter_deprecated_nodes = false
append_sub_userinfo = true
clash_use_new_field_name = true

# Generate style of the proxies and proxy groups section of Clash subscriptions.
# Supported styles: block, flow, compact
# Block: - name: name1    Flow: - {name: name1, key: value}    Compact: [{name: name1, key: value},{name: name2, key: value}]
#         key: value           - {name: name2, key: value}
#       - name: name2
#         key: value
clash_proxies_style = "flow"
clash_proxy_groups_style = "block"

# add Clash mode to sing-box rules, and add a GLOBAL group to end of outbounds
singbox_add_clash_modes = true

[[node_pref.rename_node]]
match = '\(?((x|X)?(\d+)(\.?\d+)?)((\s?å€ç‡?)|(x|X))\)?'
replace = "$1x"

import = "snippets/rename_node.toml"

[managed_config]
# Append a '#!MANAGED-CONFIG' info to Surge configurations
write_managed_config = true

# Address prefix for MANAGED-CONFIG info, without the trailing "/".
#managed_config_prefix = "https://subconverter.xiaosi.cc"
managed_config_prefix = "http://127.0.0.1:25500"
# managed_config_prefix = "http://10.18.96.99:25500"

# Managed config update interval in seconds, determine how long the config will be updated.
config_update_interval = 86400

# If config_update_strict is set to true, Surge will require a force update after the interval.
config_update_strict = false

# Device ID to be written to rewrite scripts for some version of Quantumult X 
quanx_device_id = ""

[surge_external_proxy]
#surge_ssr_path = "/usr/bin/ssr-local"
resolve_hostname = true

[emojis]
add_emoji = true
remove_old_emoji = true

[[emojis.emoji]]
#match = '(æµé‡|æ—¶é—´|åº”æ€¥)'
#emoji = 'ğŸ³ï¸â€ğŸŒˆ'
import = "snippets/emoji.toml"

[[custom_groups]]
import = "snippets/groups.toml"

# [[custom_groups]]
# name = "Auto"
# type = "url-test"
# rule = [".*"]
# url = "http://www.gstatic.com/generate_204"
# interval = 300
# tolerance = 150
# lazy = true

# [[custom_groups]]
# name = "Proxy"
# type = "select"
# rule = [".*", "[]DIRECT"]
# disable_udp = false

# [[custom_groups]]
# name = "LoadBalance"
# type = "load-balance"
# rule = [".*", "[]Proxy", "[]DIRECT"]
# interval = 100
# strategy = "consistent-hashing"
# url = "http://www.gstatic.com/generate_204"

[ruleset]
# Enable generating rules with rulesets
enabled = true

# Overwrite the existing rules in rule_base
overwrite_original_rules = false

# Perform a ruleset update on request
update_ruleset_on_request = false

# [[rulesets]]
# group = "Proxy"
# ruleset = "https://raw.githubusercontent.com/DivineEngine/Profiles/master/Surge/Ruleset/Unbreak.list"
# type = "surge-ruleset"
# interval = 86400

[[rulesets]]
import = "snippets/rulesets.toml"

[template]
template_path = ""

[[template.globals]]
key = "clash.http_port"
value = "7890"

[[template.globals]]
key = "clash.socks_port"
value = "7891"

[[template.globals]]
key = "clash.allow_lan"
value = "true"

[[template.globals]]
key = "clash.log_level"
value = "info"

[[template.globals]]
key = "singbox.allow_lan"
value = "true"

[[template.globals]]
key = "singbox.mixed_port"
value = "2080"

[[aliases]]
uri = "/clash"
target = "/sub?target=clash"

[[aliases]]
uri = "/clashr"
target = "/sub?target=clashr"

[[aliases]]
uri = "/surge"
target = "/sub?target=surge"

[[aliases]]
uri = "/quan"
target = "/sub?target=quan"

[[aliases]]
uri = "/quanx"
target = "/sub?target=quanx"

[[aliases]]
uri = "/mellow"
target = "/sub?target=mellow"

[[aliases]]
uri = "/surfboard"
target = "/sub?target=surfboard"

[[aliases]]
uri = "/loon"
target = "/sub?target=loon"

[[aliases]]
uri = "/singbox"
target = "/sub?target=singbox"

[[aliases]]
uri = "/ss"
target = "/sub?target=ss"

[[aliases]]
uri = "/ssd"
target = "/sub?target=ssd"

[[aliases]]
uri = "/sssub"
target = "/sub?target=sssub"

[[aliases]]
uri = "/ssr"
target = "/sub?target=ssr"

[[aliases]]
uri = "/v2ray"
target = "/sub?target=v2ray"

[[aliases]]
uri = "/trojan"
target = "/sub?target=trojan"

[[aliases]]
uri = "/test"
target = "/render?path=templates/test.tpl"

#[[tasks]]
#name = "tick"
#cronexp = "0/10 * * * * ?"
#path = "tick.js"
#timeout = 3

[server]
listen = "0.0.0.0"
port = 25500
serve_file_root = "web"

[advanced]
log_level = "debug"
print_debug_info = true
max_pending_connections = 10240
max_concurrent_threads = 4
max_allowed_rulesets = 64
max_allowed_rules = 0
max_allowed_download_size = 0
enable_cache = true
cache_subscription = 60
cache_config = 300
cache_ruleset = 21600
script_clean_context = true
async_fetch_ruleset = false
skip_failed_links = true
